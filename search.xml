<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无锡宜家]]></title>
    <url>%2F2020%2F05%2F25%2F%E6%97%A0%E9%94%A1%E5%AE%9C%E5%AE%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[从需求到实现的宠物顺风车系统]]></title>
    <url>%2F2020%2F02%2F20%2F%E4%BB%8E%E9%9C%80%E6%B1%82%E5%88%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%A0%E7%89%A9%E9%A1%BA%E9%A3%8E%E8%BD%A6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一,产品需求分析1,产品的功能框架a 功能框架脑图b 用户使用路径 ​ 2,产品的宏观环境分析a，定义市场​ 该产品的目的是建立一个需要托运宠物和司机的平台，当获取一定用户基数后尝试与宠物商店，猫舍狗舍进行合作，提供一条全新的宠物购买渠道。故定义为“宠物运送平台“。 b, 收集数据​ 根据5118指数 ​ “宠物托运”关键字 ​ 流量数据：986 ​ 移动指数： 985 ​ 360指数: 35 ​ pc日检索量:125 3,用户画像​ 该产品的用户对象主要针对于以下特点： ​ a,没有驾驶基础再异地购买宠物者 ​ b, 过于繁忙无空去外地接送购买宠物者 ​ c, 想赚取一定报酬并且顺路的司机 ​ d,专职运送宠物的私家车司机 二,产品原型设计1,注册登录界面的设计 2，注册后的身份选择 3,登录进入主界面（运送宠物）]]></content>
      <categories>
        <category>产品实现</category>
      </categories>
      <tags>
        <tag>-vue -axure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于不同需求采取的不同方案及基础构建方法‘]]></title>
    <url>%2F2020%2F01%2F22%2F%E5%AF%B9%E4%BA%8E%E4%B8%8D%E5%90%8C%E9%9C%80%E6%B1%82%E9%87%87%E5%8F%96%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%A1%88%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95%E2%80%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[electron实战指南]]></title>
    <url>%2F2019%2F11%2F18%2Felectron%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[一，整体构思​ 本项目将基于electron搭建一个跨平台的桌面应用，其应用的主要内容是推送壁纸，mv，和个人blog. 实现方法：​ 壁纸：puppeteer爬虫 ​ mv:开源的网易云api ​ blog:nodejs后台的搭建（基于koa，这次不选择express) ​ 登录注册：mongodb(主要为mongoose) ​ 富文本编辑器：kindeditor ​ 页面的实现:vue vue-electorn 二，创建项目​ vue的项目构建不bb了，具体参考https://www.jianshu.com/p/d2ab300f8a9a，该文配置很详细 ​ 另外由于vue-cli如今已经是4版本了，2.9.6虽然主流但太老了，所以本篇文章vue是4.0.0版本 项目结构12345678910111213141516├──node_modules // 安装包文件├──public // 即先前vue-cli版本的index.html├──src //主文件│ ├──assets //静态文件存放目录│ ├──components //组件目录│ ├──router //路由目录│ ├──stroe //vuex目录│ ├──views //页面目录│ ├──App.vue //Vue主页面│ ├──background.js //electron配置文件│ ├──main.js //Vue入口文件├──.gitgnore //git文件├──babel.config.js //babel配置文件├──package-lock.js //安装包配置文件├──package.json //包文件├──README.md //说明文件 项目结构到此为止 三， 配置准备​ 开始构建项目前，需要对electron做一些个性化的配置 background.js 1234567891011121314//配置窗口大小 win = new BrowserWindow(&#123; width: 1200, height: 800, webPreferences: &#123; nodeIntegration: true &#125; &#125;)//取消跨域设置webPreferences: &#123; webSecurity:false, nodeIntegration: true &#125;//取消菜单栏，该项目的目标是制作桌面应用，因此菜单栏保留，如要去除请转教程 改变应用图标 ​ 准备256*256的ico文件放于public文件夹中 background.js 1icon: `$&#123;__static&#125;/yourname.ico` 这样基本的配置已经完成了 打开我们可以看到以上的内容，在下一节我们会开始将App.vue构建成一个完美的主页面。]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>electron -vue -mongodb -nodejs -koa -bootstrap -puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa源码解析]]></title>
    <url>%2F2019%2F11%2F06%2Fkoa%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[######]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts的函数继承与类的修饰符]]></title>
    <url>%2F2019%2F11%2F01%2Fts%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一，ts的继承 ts的基本依靠于extends和super分别获取到类的类型和类名从而继承 123456789101112131415161718class Person&#123; name:string constructor(name:string)&#123; this.name = name &#125; run():string&#123; return `$&#123;this.name&#125;+"在锻炼"` &#125;&#125;//创建一个类class Web extends Person&#123; constructor(name:string)&#123; super(name) &#125; work():string&#123; return `$&#123;this.name&#125;+"在工作"` &#125;&#125; 二，类的修饰符ts关于类的修饰符分为三种，用于指定类名的公开程度 12345/* public 公开，类和子类和外部都可以使用 protected 保护，只有类和子类能使用 private 私有，仅有类本身可以使用*/ 个人觉得typescript的学习知识让你更好的认识到js的一些不足并能够让自己可以意识到这些问题。如今的开发中应用较多的mvc和mvvm甚至是微信小程序的模式（十分类似于基于vue的mvvm）一个主要依靠于jqeury一个依靠于vue，两者都不是基于typescript的，可能当ts的库和更多的框架出现时会逐渐的优于js吧。]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts的函数]]></title>
    <url>%2F2019%2F11%2F01%2Fts%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一, 定义函数的方式1，函数声明123function run():string &#123; return &quot;run&quot;&#125; 2, 匿名函数123var run = function():string &#123; return &quot;run&quot; &#125; 二，函数传参1234567891011//声明function getinfo(name:string,age:number)&#123; return `$&#123;name&#125;-----$&#123;age&#125;`&#125;alert(getinfo(&apos;张三&apos;),18)//匿名var getinfo = function(name:string,age:number)&#123; return `$&#123;name&#125;-----$&#123;age&#125;`&#125; 三， 可选参数12345function getinfo(name:string,age?:number)&#123; return `$&#123;name&#125;`&#125;//可选参数放置于后面 四，默认参数五，剩余参数123456789function sum(1,2,...result):number&#123; var sum = 0 for(var i=0,i&lt;result.length,i++)&#123; sum += result[i] &#125; return sum&#125;alert(sum(1,2,3,4,5)) 六，函数重载]]></content>
      <categories>
        <category>-前</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts在vscode的配置以及其数据类型]]></title>
    <url>%2F2019%2F10%2F31%2Fts%E5%9C%A8vscode%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一，配置vscode123456//终端tsc init //获取配置文件//tsconfig.json//打开outDir 设置js文件生成的默认路径//打开 &quot;experimentalDecorators&quot;: true使ts支持es7语法 之后再终端(T)中开启监听任务，则每次保存ts文件都会转化成js 二， ts的数据类型ts对于数据类型的定义比js严格的多，在通过var定义时(const和let也可以规定，但是因为他们的唯一性应该不需要设定)，一旦规定数据类型，下之后代码中更改变量若不为相同类型会产生报错 12var str:string = 'admin'//之后的str只能为字符串 ts的数据类型有String,Number,Array,Boolean,Tuple,enum,any,null,undefinded,never,void想比较与javascript,少了object对象，多出了tuple元组类型，any任意类型，enum枚举类型，never类型和void类型1，tuple元组类型属于数组，是拥有多个数据类型的数组，因为在ts中严格规定的arrary的数据类型，当有多重类型时可以使用元组，但是规定的类型数量必须和数组内元素数量相同 1let arr:[number,string] = [1,'1'] 2,anyany类型可以适用于所有的类型 1var a:any = [1,2,4,&quot;2121&quot;] 3,enum枚举类型用于将特定的时间变为数字下标来表示 1234enum Err &#123;"undefinded"==-1,'unll'==-2,'success'=1&#125;const U:Err = Err['undefinded']consoloe.log(U) // -1//当没有规定数字时默认为从0开始的下标 4，voidvoid用于规定没有返回的函数 123function run():void&#123; console.log('run')&#125; 5, nevernever基本可以使用any代替，用于表示其他数据 123(()=&gt;&#123; throw new Error('err')&#125;)()]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>tpyescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex相关]]></title>
    <url>%2F2019%2F10%2F24%2Fvuex%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[一， vuex引入使用引入1npm i vuex在src目录下新建store文件夹 在文件夹中创建 index.js //主文件 state.js // 状态文件 getters.js // 计算属性文件 mutations.js // 状态事件文件 actions.js // 更变状态文件(可异步) main.js中 123import store from &apos;./store&apos;components:&#123;store&#125; index.js中 12345678910111213141516import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import state from &apos;./state&apos;import mutations from &apos;./mutations&apos;import actions from &apos;./actions&apos;import getters from &apos;./getters&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 其他四个js中 123export default(&#123; &#125;)]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express配置]]></title>
    <url>%2F2019%2F10%2F19%2Fexpress%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[通过express自带的模板创建带有许多基本上用不到的功能，不如自己配置一个简单易懂的expressapp.js 1234567891011121314151617181920212223242526272829303132333435var express = require(&apos;express&apos;)var app = express()var router = require(&apos;./router&apos;)var bodyParser = require(&apos;body-parser&apos;)var path = require(&apos;path&apos;)var session = require(&apos;express-session&apos;)const MongoStore = require(&apos;connect-mongo&apos;)(session)app.use(&apos;/node_modules/&apos;, express.static(path.join(__dirname, &apos;./node_modules/&apos;)))app.use(session(&#123; secret: &apos;keyboard cat&apos;, resave: false, saveUninitialized: true, rolling: true, cookie: &#123; maxAge: 1000 * 60 * 60 * 24 &#125;, store: new MongoStore(&#123; url: &quot;mongodb://localhost/device&quot;, touchAfter: 24 * 3600 &#125;)&#125;))app.use(&apos;/node_modules/&apos;, express.static(path.join(__dirname, &apos;./node_modules/&apos;)))app.use(&apos;/public/&apos;, express.static(path.join(__dirname, &apos;./public/&apos;)))app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json())app.use(router)app.use(function (req, res) &#123; res.render(&apos;404.html&apos;)&#125;)app.listen(3000, function () &#123; console.log(&quot;监听成功&quot;)&#125;) router.js 1234var express = require(&quot;express&quot;)var router = express.Router()module.exports = router 后台只要这些配置，至于是做前后端不分离的mvc还是分离的mvvm的配置看需要再加减]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>express -nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目的坑]]></title>
    <url>%2F2019%2F10%2F19%2Fvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[想到一点写一点一， 关于路由懒加载​ 由于mvvm的特性页面的路由转换不会触发页面的跳转，因此在vue-cli项目完成时他的app.js文件会特别庞大，这对于小型服务器的加载是致命问题，路由的懒加载可以让app.js的读取舍弃未用到的路由组件，当用到的时候再加载 12345678910export default new Router(&#123; routes:[ &#123; path: &apos;/my&apos;, name: &apos;my&apos;, //懒加载 component: resolve =&gt; require([&apos;../page/my/my.vue&apos;], resolve), &#125;, ]&#125;) ​ 二， 引入多个ui组件​ 尽管类似于mint-ui这样的过气组件现在用处不是很大，但是有一些独有的特性还是会用得到，因此要要在一个vue项目中会用到element-ui,bootstrap,mint-ui等多个组件 ​ 建议全部都按需引用 main.js1234567import &#123; Tabbar, TabItem, Header &#125; from &apos;mint-ui&apos;;import &#123; Input &#125; from &apos;element-ui&apos;Vue.component(Input.name, Input)Vue.component(Header.name, Header)Vue.component(Tabbar.name, Tabbar);Vue.component(TabItem.name, TabItem); .babeirc12345678910111213141516171819202122232425&#123; &quot;presets&quot;: [ [ &quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125; ] ], &quot;plugins&quot;: [ [ &quot;component&quot;, [ &#123; &quot;libraryName&quot;: &quot;mint-ui&quot;, &quot;style&quot;: true &#125;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ] ]&#125; 三， axios引用方法123456import axios from &apos;axios&apos;Vue.prototype.axios = axios//全局引用后可以在全局通过this.axios调用//若在但组件内import//可在该组件之间用axios 四， 兄弟组件传值原生vue中兄弟组件传值要通过父组件做中间件再传值非常麻烦，这里用pubsub可以很好解决 1234npm i pubsub-jsimport PubSub from &apos;pubsub-js/src/pubsub&apos;Vue.use(PubSub) 兄弟组件a1PubSub.publish(&apos;setmsg&apos;,data) //发布文件 兄弟组件b1PubSub.subscribe(&apos;getmsg&apos;,msg)//订阅文件 此时msg的值就是data 五， 主界面问题方法一大堆不写了六， 移动端的自适应终端 123npm i lib-flexible --savenpm install px2rem-loader main.js 1import &apos;lib-flexible/flexible&apos; index.html 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 12 until.js 123456789const px2remLoader = &#123; loader:&apos;px2rem-loader&apos; options:&#123; remUnit:75 &#125;&#125;//在generateLoaders中const loaders = options................]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>-vue-cli -vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session持久化问题]]></title>
    <url>%2F2019%2F10%2F10%2Fsession%E6%8C%81%E4%B9%85%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一 ，问题来源​ 在做web相关的需求时候一旦涉及到登录注册组件那就必然离不开cookie和session这两个东西。session是基于服务器进行存储的，所以当服务器进行重启亦或是掉线时所有的session数据都回摧毁，那么如何才能使session能在一段时间内持续存在呢？ 二 ， 解决办法​ 需要用到express-session以及connect-mongo 12var session = require(&apos;express-session&apos;)const MongoStore = require(&apos;connect-mongo&apos;)(session) ​ 然后再进行相关配置 12345678910111213app.use(session(&#123; secret:&apos;keyboard cat&apos;, resave:false, saveUninitialized:true, rolling:true, cookie:&#123; maxAge:1000*30*60 &#125;, store:new MongoStore(&#123; url:&quot;mongodb://localhost/device&quot;, touchAfter:24 * 3600 &#125;)&#125;)) 之后再到router之中定义session 三 ， 两个端口之间的跨域问题直接上代码，复制粘贴便可 1234567app.all(&apos;*&apos;,(req,res,next)=&gt;&#123; res.header(&quot;Access-Control-Allow-Credentials&quot;,&apos;true&apos;) res.header(&quot;Access-Control-Allow-Origin&quot;,req.headers.origin) res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,GET,POST,DELETE,OPTIONS&quot;) res.header(&apos;Access-Control-Allow-Headers&apos;,&quot;Content-Type,username&quot;) next()&#125;) 结束！]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>-express -nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础项目留言本]]></title>
    <url>%2F2019%2F10%2F03%2Fvue%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E7%95%99%E8%A8%80%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[一 。创建项目参考上文，这里不多说二 。 静态页面首先考虑当前界面到底需要几个模板 在这里考虑到了四个组件 APP.vue作为主界面框架 add.vue作为表单的组件 list.vue作为表格组件 ltem.vue作为每行列表的组件 组件传递当父组件向子组件传递内容时 父组件通过 1v-bind:XXX=&apos;XXX&apos; 绑定元素 子组件通过 123prop：&#123; XXX&#125; 获取元素 组件调用当父组件需要调用这个子组件时 父组件通过 1import XXX from &apos;xxx&apos; 获取子组件 然后 123components:&#123; XXX&#125; 调用子组件]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3配置（若前文无法打开请看这篇）]]></title>
    <url>%2F2019%2F10%2F03%2Fwebpack3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一，基本配置1.创建src文件夹用于存放主文件​ 2.创建dist文件夹存放webpack转换过的文件3.在根目录下创建webpack.config.js文件用于修改webpack配置4.在src文件夹中创建index.html（随意，建议遵循mvc建立views文件夹），main.js（所有js和css的入口文件）在html不导入任何的js和css包 二，详细配置1.webpack-dev-server该组件用于自动将src的文件打包到dist变成webpack格式输出 123456789101112131415161718192021&lt;!--&gt;终端&lt;--!&gt;npm init -y //初始化项目npm init webpack-dev-server //安装组件&lt;!--&gt;package.json&lt;--!&gt; "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot"&#125;//执行自动打开 绑定3000端口 设src为根目录 启动热更新&lt;!--&gt;配置文件&lt;--!&gt;const path = require('path')module.exports = &#123; entry:path.join(__dirname,'./src/main.js'), //入口文件 output:&#123; path:path.join(__dirname,'./dist'),//出口文件 filename:'bundle.js' &#125;&#125; 2.html-webpack-plugin该组件用于自动生成一个和html相同的界面并且导入bundle.js 123456789101112&lt;!--&gt;终端&lt;--!&gt;npm i html-webpack-plugin&lt;!--&gt;配置文件&lt;--!&gt;plugins:[ new webpack.HotModuleReplacementPlugin(),//new一个热更新的模块对象 new htmlWbppackFlugin(&#123; //创建一个在内存中生成html页面的插件 template:path.join(__dirname,'./src/index.html'),//指定模板页面 filename:'index.html' &#125;) ] 3.导入css/sass/图标/图像url等文件通过各种loader让webpack能够识别这些东西 123456789101112 &lt;!--&gt;终端&lt;--!&gt;npm i css-loader file-loadernpm i url-loader &lt;!--&gt;配置文件&lt;--!&gt; module:&#123;//这个节点用于配置所有的第三方模块加载器 rules:[//所有模块的匹配规则 &#123; test: /\.css$/ ,use:['style-loader','css-loader']&#125;, &#123; test: /\.(jpg|png|gif|jepg)$/,use:'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]'&#125;,//读取图片 &#123; test: /\.(ttf|eot|svg|woff|woff2)$/,use:"url-loader"&#125;//处理字体文件 ] &#125; 4.通过babel插件来识别es6等高级语言1234567891011&lt;!--&gt;终端&lt;--!&gt;npm i babel-core babel-loader babel-plugin-transform-runtimenpm i babel-preset-env babel-preset-stage-0&lt;!--&gt;配置文件&lt;--!&gt; rules:[//所有模块的匹配规则 &#123; test: /\.css$/ ,use:['style-loader','css-loader']&#125;, &#123; test: /\.(jpg|png|gif|jepg)$/,use:'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]'&#125;,//读取图片 &#123; test: /\.(ttf|eot|svg|woff|woff2)$/,use:"url-loader"&#125;,//处理字体文件 &#123; &#123;test:/\.js$/,use:"bebel-loader",exclude:/node_modules/&#125;&#125;//在配置时，必须把node_modules排除 ] 然后在根目录新建一个.babelrc的配置文件，为json格式 12"presets":["env","stage-0"],"plugins":["transform-runtime"] 注意 由于本文是基于webpack3.X的配置，目前普遍使用4.X.因此，babel-core的版本必须降为6.X并且babel-loader的版本必须降到7.X，不然你会被报错到怀疑人生。如果你已经将上面的配置操作完毕并且对html，css等操作没有报错的话，拿webpack3.X的配置就基本okk了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过vue-cli创建vue项目]]></title>
    <url>%2F2019%2F10%2F02%2F%E9%80%9A%E8%BF%87vue-cli%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[12345npm i -g vue-cli //建议使用全局安装不然的话vue指令无法识别vue init webpack vue_demo //创建名为vue_demo的基于webpack的项目cd vue_demo //进入项目npm i //初始化项目npm run dev //运行项目 完工]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.X集合webpack3.X时的各种坑]]></title>
    <url>%2F2019%2F09%2F20%2Fvue2-X%E9%9B%86%E5%90%88webpack3-X%E6%97%B6%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一.vue的引用由于默认的main属性是属于vue.common.js而不是vue.js，因此如果进行普通引入 1import Vue from &apos;vue&apos; 是无法正常运行的。 解决方法：1.直接导入vue路径 1import Vue from &apos;../node_module/vue/dist/vue.js&apos; 2.在webpack配置项中对路径进行改动 12345resolve:&#123; alias:&#123; //修改路径 &quot;vue$&quot;:&quot;vue/dist/vue.js&quot; &#125; &#125; 二.xxx.vue如何让html接受vue文件默认不被webpack识别，因此在进行render等模块操作时候需要导入loader 解决方法123npm i vue-loader vue-template-compiler &#123;test:/\.vue$/,use:&quot;vue-loader&quot;&#125; 正常的话就可以进行vue与webpack的合作了 。。 然而你还是被报错报成猪头的话 123const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;)new VueLoaderPlugin() 在配置文件的全局和plugins下分别加入这两条代码就可以识别了]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-vue -webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3.X详细配置指南]]></title>
    <url>%2F2019%2F09%2F20%2Fwebpack3-X%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[一，基本配置1.创建src文件夹用于存放主文件​ 2.创建dist文件夹存放webpack转换过的文件3.在根目录下创建webpack.config.js文件用于修改webpack配置4.在src文件夹中创建index.html（随意，建议遵循mvc建立views文件夹），main.js（所有js和css的入口文件）在html不导入任何的js和css包 二，详细配置1.webpack-dev-server该组件用于自动将src的文件打包到dist变成webpack格式输出 123456789101112131415161718192021&lt;!--&gt;终端&lt;--!&gt;npm init -y //初始化项目npm init webpack-dev-server //安装组件&lt;!--&gt;package.json&lt;--!&gt; "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot"&#125;//执行自动打开 绑定3000端口 设src为根目录 启动热更新&lt;!--&gt;配置文件&lt;--!&gt;const path = require('path')module.exports = &#123; entry:path.join(__dirname,'./src/main.js'), //入口文件 output:&#123; path:path.join(__dirname,'./dist'),//出口文件 filename:'bundle.js' &#125;&#125; 2.html-webpack-plugin该组件用于自动生成一个和html相同的界面并且导入bundle.js 123456789101112&lt;!--&gt;终端&lt;--!&gt;npm i html-webpack-plugin&lt;!--&gt;配置文件&lt;--!&gt;plugins:[ new webpack.HotModuleReplacementPlugin(),//new一个热更新的模块对象 new htmlWbppackFlugin(&#123; //创建一个在内存中生成html页面的插件 template:path.join(__dirname,'./src/index.html'),//指定模板页面 filename:'index.html' &#125;) ] 3.导入css/sass/图标/图像url等文件通过各种loader让webpack能够识别这些东西 123456789101112 &lt;!--&gt;终端&lt;--!&gt;npm i css-loader file-loadernpm i url-loader &lt;!--&gt;配置文件&lt;--!&gt; module:&#123;//这个节点用于配置所有的第三方模块加载器 rules:[//所有模块的匹配规则 &#123; test: /\.css$/ ,use:['style-loader','css-loader']&#125;, &#123; test: /\.(jpg|png|gif|jepg)$/,use:'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]'&#125;,//读取图片 &#123; test: /\.(ttf|eot|svg|woff|woff2)$/,use:"url-loader"&#125;//处理字体文件 ] &#125; 4.通过babel插件来识别es6等高级语言1234567891011&lt;!--&gt;终端&lt;--!&gt;npm i babel-core babel-loader babel-plugin-transform-runtimenpm i babel-preset-env babel-preset-stage-0&lt;!--&gt;配置文件&lt;--!&gt; rules:[//所有模块的匹配规则 &#123; test: /\.css$/ ,use:['style-loader','css-loader']&#125;, &#123; test: /\.(jpg|png|gif|jepg)$/,use:'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]'&#125;,//读取图片 &#123; test: /\.(ttf|eot|svg|woff|woff2)$/,use:"url-loader"&#125;,//处理字体文件 &#123; &#123;test:/\.js$/,use:"bebel-loader",exclude:/node_modules/&#125;&#125;//在配置时，必须把node_modules排除 ] 然后在根目录新建一个.babelrc的配置文件，为json格式 12"presets":["env","stage-0"],"plugins":["transform-runtime"] 注意 由于本文是基于webpack3.X的配置，目前普遍使用4.X.因此，babel-core的版本必须降为6.X并且babel-loader的版本必须降到7.X，不然你会被报错到怀疑人生。如果你已经将上面的配置操作完毕并且对html，css等操作没有报错的话，拿webpack3.X的配置就基本okk了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs最实用分页攻略]]></title>
    <url>%2F2019%2F09%2F20%2Fnodejs%E6%9C%80%E5%AE%9E%E7%94%A8%E5%88%86%E9%A1%B5%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[话不多说直接开始1.准备工作​ 在你看这篇文章想要进行分页时，请确保已经做好以下准备工作 ​ ——你的html页面已经搭建完成（表格，上一页/下一页，页面跳转） ​ ——你的后台数据已经通过模板或者循环成功的渲染到你的前台表格 2.给他们做一个点击事件，通过switch（if）操作1234567891011121314151617181920212223242526272829303132function jump(type) &#123; var nowpage = $('#nowpage').text() var allpage = $('#allpage').text() switch (type) &#123; case 'prev': if (nowpage &gt; 1) &#123; nowpage-- &#125; else &#123; alert('已经是第一页了') &#125; ; break; case 'next': if (nowpage &lt; allpage) &#123; nowpage++ &#125; else &#123; alert('已经是最后一页了') &#125; ; break; case 'go': if ($('#gopage').val() &gt; allpage) &#123; alert('输入页数错误了') &#125; else if ($('#gopage').val() &lt; 1) &#123; alert('输入页数错误了') &#125; else &#123; nowpage = $('#gopage').val() &#125;; break; &#125; window.location.href = '/create?page='+nowpage+''&#125; 3.后台操作1234567891011121314151617181920212223router.get('/create',function(req,res)&#123; var pagesize = req.query.pagesize || 10 var page = req.query.page || 1 var allcount1 = null Journalism.count(&#123;&#125;,function(err,allcount)&#123; if(err)&#123; res.status(500).send("Server Not Found") &#125; allcount1 = allcount &#125;) Journalism.find(function(err,journalisms)&#123; if(err)&#123; return res.status(500).send("Server Not Found") &#125; res.render('create.html',&#123; journalisms:journalisms, user:req.session.user, nowpage:page, allpage:Math.ceil(allcount1/pagesize) &#125;) &#125;).sort(&#123;'datatime':-1&#125;).limit(pagesize).skip((page-1)*pagesize) &#125;) 基本分页就此完成]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs在表单中添加验证码验证]]></title>
    <url>%2F2019%2F09%2F20%2Fnodejs%E5%9C%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%A0%81%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[废话不多说了直接开始吧1，好一个简单的表单页面，just like，懒得改格式了你们将就哈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;form id="formlist"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleFormControlInput1"&gt;您的姓名&lt;/label&gt; &lt;input type="text" class="form-control" id="exampleFormControlInput1" placeholder="请输入正确的姓名方便我们的联系" name="username"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleFormControlInput1"&gt;您的邮箱&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleFormControlInput1" placeholder="请输入正确的邮箱方便我们的联系" name="emial"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleFormControlInput1"&gt;您的手机号码&lt;/label&gt; &lt;input type="text" class="form-control" id="exampleFormControlInput1" placeholder="请输入正确的手机号方便我们的联系" name="phone"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleFormControlSelect1"&gt;应聘合作相关&lt;/label&gt; &lt;select class="form-control" id="exampleFormControlSelect1" name="class"&gt; &lt;option&gt;应聘&lt;/option&gt; &lt;option&gt;合作&lt;/option&gt; &lt;option&gt;投诉&lt;/option&gt; &lt;option&gt;建议&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleFormControlTextarea1"&gt;具体内容&lt;/label&gt; &lt;textarea class="form-control" id="exampleFormControlTextarea1" rows="3" name="note"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type="text" placeholder="验证码" id="svgtext" name="svg"&gt; &lt;img src='/ver' onclick='changeSvg()' id="svgimg"&gt; &lt;br&gt; &lt;br&gt; &lt;div class="alert alert-warning" role="alert" id="control"&gt; 请输入验证码 &lt;/div&gt; &lt;br&gt; &lt;button type="button" class="btn btn-primary" data-toggle="modal" data-target="#exampleModal"&gt; 确认提交信息 &lt;/button&gt; &lt;!-- Modal --&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;h5 class="modal-title" id="exampleModalLabel"&gt;提交您的信息&lt;/h5&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; 请确认您填写的信息准确从而方便我们之间的联系 &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-secondary" data-dismiss="modal"&gt;再想想&lt;/button&gt; &lt;button type="submit" class="btn btn-primary"&gt;确定了&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 2.然后我们在router.js端做个验证码12345678var captcha = require('svg-captcha')router.get('/ver',function(req,res)&#123; var cap = captcha.create(); req.session.captcha = cap.text res.type('svg') res.send(cap.data);&#125;) 这样一来图片img的src路径指向该理由，从而显示验证码图片 3.做一个点击事件12345&lt;script&gt; function changeSvg()&#123; $(event.target).attr('src','/ver?'+Math.random()) &#125; &lt;/script&gt; 4.最后便是提交表单的ajax了12345678910111213141516171819202122232425262728$('#formlist').on('submit',function(e)&#123; e.preventDefault() var formData = $(this).serialize() $.ajax(&#123; type:'post', url:'/person', data:formData, dataType:'json', success:function(data)&#123; var err_code =data.err_code if(err_code===500)&#123; window.alert("服务器出错啦") &#125; else if(err_code===1)&#123; window.alert("验证码错误请重试") $('#control').attr("class","alert alert-danger") $('#control').text('请输入正确的验证码,注意大小写的区分哦') $('#svgimg').attr('src','/ver?'+Math.random()) &#125; else if(err_code===0)&#123; window.alert("您的信息已经提交成功") $('#control').attr("class","alert alert-success") $('#control').text('验证码输入正确') window.location.href = '/person' &#125; &#125; &#125;)&#125;) 关于表单提交的post路由就不贴了，这样一个验证系统就差不多多好了( ´Д`)y━・ 如有问题可以提问]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在node项目中经常用到的一些东西]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%9C%A8node%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[一.引入body-parserapp.js1234var bodyParser = require('body-parser')app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json()) #### 二.引入sessionapp.js1234567var session = require('express-session')app.use(session(&#123; secret:'keyboard cat', resave:false, saveUninitialized:true&#125;)) router.js12345678910111213141516171819202122232425router.post('/login',function(req,res)&#123; var body = req.body User.findOne(&#123; emial:body.emial, password:body.password &#125;,function(err,user)&#123; if(err)&#123; return res.status(500).json(&#123; err_code:500, messages:"err" &#125;) &#125; if(!user)&#123; return res.status(200).json(&#123; err_code:0, messages:"emial has benn invilied" &#125;) &#125; req.session.user = user return res.status(200).json(&#123; err_code:1, messages:"ok" &#125;) &#125;)&#125;) 三.引入multerrouter.js1234567891011121314151617181920212223242526272829var multer =require('multer')var storage = multer.diskStorage(&#123; destination:function(req,file,cb)&#123; cb(null,'./uploads/qua-img') &#125;, filename:function(req,file,cb)&#123; var ext = file.originalname.split('.')[1] var tmname = (new Date()).getTime()+parseInt(Math.random()*9999) cb(null,''+tmname+'.'+ext+'') &#125;&#125;)var upload = multer(&#123; storage:storage&#125;);router.post('/qua-pic',function(req,res)&#123; var size= req.file if(size&gt;500000)&#123; res.status(500).json(&#123; err_code:-1, messages:"pic too big" &#125;) &#125; res.status(200).json(&#123; err_code:0, messages:"okk" &#125;)&#125;) 四.ajax模板xxx.js1234567891011121314151617181920$('#create-form').on('submit',function(e)&#123; e.preventDefault() var formData = $(this).serialize() $.ajax(&#123; type:'post', url:'/create', data:formData, dataType:'json', success:function(data)&#123; var err_code =data.err_code if(err_code===500)&#123; window.alert("服务器出错啦") &#125; else if(err_code===0)&#123; window.alert("提交成功") window.location.href='/create' &#125; &#125; &#125;)&#125;) 五.art-templateapp.js1app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;)) 六.router配置app.js123var router = require('./router')app.use(router) ​ router.js 123var router =express.Router()module.exports = router 七.获取图片1234567891011121314151617181920212223var fs =require('fs')exports.getAllimgs = function(callback)&#123; fs.readdir('./uploads/qua-img',function(err,files)&#123; if(err)&#123; callback(err) return &#125; var allimgs = []; (function iterator(i)&#123; if(i==files.length)&#123; callback(allimgs) return &#125; fs.stat('./uploads/qua-img/'+files[i],function(err,stats)&#123; if(stats.isFile())&#123; allimgs.push(files[i]) &#125; iterator(i+1) &#125;) &#125;)(0) &#125;)&#125; 八.kindeditor引入123456789101112131415161718192021222324252627KindEditor.ready(function(K) &#123; editor = K.create('textarea[name="content"]', &#123; allowFileManager : true, afterBlur: function()&#123;this.sync();&#125;, uploadJson: '/uploadImg' &#125;);&#125;);router.post('/uploadImg',function(req,res,next)&#123; var form = new formidable.IncomingForm() form.keepExtensions = true form.uploadDir =__dirname + '/public/upload' form.parse(req,function(err,fields,files)&#123; if(err)&#123; throw err &#125; var image = files.imgFile; var path = image.path path = path.replace('/\\/g','/') var url = '/upload' +path.substr(path.lastIndexOf('/'),path.length) var info = &#123; "error":0, "url":url &#125;; res.send(info) &#125;)&#125;) 持续更新..]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>便捷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node+mongoose增删改查思路]]></title>
    <url>%2F2019%2F09%2F16%2Fnode-mongoose%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[1.建立views视图页面 界面名称 url地址 index.html /home table.html /table edit.html /table/edit 2.安装相关模块插件12345678npm i -S express //安装组件npm i -S art-template npm i -S express-art-template //安装组件npm i -S body-parser //用于post获取数据npm i -g nodemon //全局安装，用于实时观察代码改动 3.建立node服务器12345678var express = require('express')var app = express() app.listen(3000,function()&#123; console.log("开始监听") &#125; &#125;) //开启端口127.0.0.1:3000的服务 4.node中启用相关插件12345678var body = require('body-parser')app.use('/public',express.static('./public/')) //用于使用public目录中的js，css等app.engine('html',require('express-art-template'))app.use(bodyParser.urlencoded([extend:false]))app.use(bodyParser.json()) 5.开启路由app.js端 123var router = require('./routers.js')app.use(router) //导入router模块 router端 1var router = express.Router() 6.定义传递方式路径 请求方式 传递路径 传递参数 备注 7.建立mongodb库1234567891011var mongoose = require(&apos;mongoose&apos;)mongoose.connect(&apos;mongodb:localhost://....&apos;)var schema = mongoose.schema()var userSchema = new schema(&#123; data:&#123;&#123;options&#125;&#125;&#125;)module.exports = mongooser.model(&quot;user&quot;,userSchema) 8.增删改查1234567891011//请自行查询mongoose语法，例：var user = require(&apos;./model/user.js&apos;)router.get(&apos;/&apos;,function(req,res)&#123; user.find(function(err)&#123; if(err)&#123; consolo.log(err) &#125; res.render(&apos;index.html&apos;) &#125;)&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F09%2F15%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[链接 有链接我为什么要自己写？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突然好想你-五月天]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%AA%81%E7%84%B6%E5%A5%BD%E6%83%B3%E4%BD%A0-%E4%BA%94%E6%9C%88%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[目录 原链接 吉他谱 弹唱 总结 让我们开始吧​ 原谱链接 低音唱什么五月天？ ​]]></content>
      <categories>
        <category>吉他谱</category>
      </categories>
      <tags>
        <tag>有谱么</tag>
        <tag>弹唱</tag>
      </tags>
  </entry>
</search>
